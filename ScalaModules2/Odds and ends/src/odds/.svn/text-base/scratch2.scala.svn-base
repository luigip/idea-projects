package odds

case class Person(pos: Int, succ: () => Person) {
  override def toString = "Person("+pos+")"
  override def equals(a: Any) = a match {
    case Person(x, _) => x == pos
    case _ => false
  } 
  //Removes self from circle and returns next Person plus indicator of whether this is the last
  //person standing
  def removed: (Person, Boolean) = {
    val next = succ()
    val prev = previous(this)
    val p = Person.chainUntil(next, prev)
    (p, this == prev)
  }  
  // finds person previous to p by going forwards
  def previous(p: Person): Person = if(succ() == p) this else succ().previous(p)
  // Gets person n steps away
  def plus(n: Int): Person = if (n == 0) this else succ().plus(n - 1)   
}

object Person {
  def first(n: Int) = chain(n)
  // Form initial chain
  def chain(N: Int, count: Int = 1): Person = count match {
    case N => Person(N, () => first(N))
    case x => Person(x, () => chain(N, x + 1))
  }
  // Create new chain from copies of firstPers and endPers, linking last to first
  def chainUntil(firstPers: Person, endPers: Person): Person = {
    lazy val first: Person = firstPers.copy(succ = ()=> loop(firstPers))
    // creates Person which is new version of p's successor
    def loop(p: Person): Person = p match {
      case `endPers` => first
      case x => x.succ().copy(succ = ()=> loop(x.succ()))
    }
    first
  }
  
  def getWinner(p: Person, step: Int): Person = p.plus(step - 1).removed match {
    case (x, true)  => x
    case (x, false) => getWinner(x, step)
  }  
}

object Main extends App {
  import Person._ 
  val res = getWinner(first(40), 3)
  println(res)
}