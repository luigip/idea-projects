package odds2

object Josephus_Imperative extends collection.mutable.ArrayBuffer[Int] with App {
  val number = 40
  val step = 3
  this ++= 1 to number
  var pos = 0
  while (size > 1) { 
    pos = (pos + step - 1) % size
    remove(pos) 
  }
  println("Winner: " + this(0))
}

object Josephus_Immutable extends App {

  case class Person(index: Int)
  
  class Circle(step: Int, inputps: Seq[Person]) {
    val ps = Vector() ++ inputps
    def nextCircle = { 
      val pos = (step - 1) % ps.size
      val newps = ps.splitAt(pos) match { case (pre, post) => post.tail ++ pre }     
      new Circle(step, newps)
    }    
    def findWinner: Person = if (ps.size == 1) ps(0) else nextCircle.findWinner
  }

  val c = new Circle(3, 1 to 40 map Person)
  println("Winner: " + c.findWinner)  
  
}

// This works, although on reflection Actors aren't a great match for this problem, 
// since their point is that they act concurrently, and the concurrency actually makes this
// more difficult (cf next solution)
object Josephus_Actors extends App {
  import actors._
  
  val N = 40
  val step = 3
  
  case class Person(id: Int) extends Actor { Self =>
    // would like to make `next` private, but it's then very tricky to set up
    var next: Person = _
    private[this] var alive = true
    def act {
      while (alive) {
        // Messages consist of (count, sender) where count is distance from last man out
        receive {
          // last man standing
          case (_, Self) => {
            println("Winner: "+id)
            sys.exit(0)
          }          
          // kill self
          case (x: Int, _) if x == step => {
            alive = false
            reply {next}
          }
          // kill next 
          case (x: Int, _) if x == step - 1 => {
            // wait until we have received our next value
            next !? ((step, Self)) match {
              case a: Person => next = a
              case _ =>                
            }
            next ! (1, Self)
          }
          /* pass on message */
          case (x: Int, _) => {
            next ! (x + 1, Self)
          }
          case other => println(id + " unrecognized message: " + other)
        }
      }
    }
  }
  
  val acts = 1 to N map Person
  acts foreach { p =>
    p.next = p.id match { 
      case N => acts(0)
      case x  => acts(x)
    }
    p.start()
  }
  acts(0) ! (1, null)  
}


// This one's basically the same as the Actors solution, just with method invocation
// rather than message passing
object Josephus_OO extends App {
  val N = 40
  val step = 3
  
  case class Person(id: Int) {
    var next: Person = _
    
    def receive(number: Int, sender: Person) {     
      if (sender == this) println("Winner: " + id)
      else if (number == 3) {
        sender.next = next
        next.receive(1, sender)
      }
      else next.receive(number + 1, this)
    }
  }

  val ps = 1 to N map Person
  ps foreach { p =>
    p.next = if (p.id == N) ps(0) else ps(p.id)
  }  
  ps.head.receive(1, null)  
}













