package odds

object Life {
  
  case class Point(x: Int, y: Int) {
    lazy val neighbours: Set[Point] = Point.neighbourCoOrds map {case(a,b) => Point(a+x,b+y)}
  }
  
  object Point {
    val neighbourCoOrds = Set((-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1))
  }
  
  
  def display(width: Int, height: Int, xs: Set[(Int, Int)]) = {
    Seq.tabulate(width, height){
      (x, y) => if (xs contains (x, y)) "X" else "  "
    }
  }

  def neighbours(x: Int, y: Int) = 
    for {
      dx <- Seq(-1, 0, 1) 
      dy <- Seq(-1, 0, 1) 
      if (dx,dy) != (0,0)
    } yield (x + dx, y + dy)

//  def ns(x: Int, y: Int) = 
//    Seq((-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1)) map {case(a,b) => (a+x,b+y)}
  
  def stepper(
//    neighbours:    (Int, Int) => List[(Int, Int)], 
    birth:         Int => Boolean, 
    survive:       Int => Boolean
  ): (Seq[(Int, Int)]) => Seq[(Int, Int)] = {
    ((alive: Seq[(Int, Int)]) => {
      val dead = 
        alive.map(c => neighbours(c._1, c._2))
             .flatten
             .distinct
             .filterNot(alive.contains)
      List((alive, survive), (dead, birth))
        .map( x => 
          (x._1.map(a =>
            (a, neighbours(a._1, a._2).intersect(alive).size))
            .filter(a => x._2(a._2)).map(a => a._1))
      ).flatten
    })
  }
}